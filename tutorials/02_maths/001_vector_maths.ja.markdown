---
.. date: 2012/02/23 10:00:00
.. title: ベクトルの計算
.. summary: ベクトル計算の基本コンセプト
.. author: Keith Pasko
---

空間内を動きまわるには、物体がどこにあって、どこへ向かって動くのか知っている必要があります。ベクトルの計算は、空間内の物をコントロールするための数学的な知識を、エレガントで、直感的で、複雑な構造や動きを汎用的な方法で使えるようになるクラスです。ベクトルはアニメーションやパーティクルシステム、3Dグラフィクスなどの核心です。実際に、ベクトル計算と線形代数は、現代のコンピュータ科学に多大な貢献をしています。

では、技術的な詳細に入っていきましょう。ベクトルは抽象的な空間内での位置と大きさを表わします。今回は「空間」を一般的な2次元や3次元の空間として考えましょう。このような世界には、一般的に「基底ベクトル」と原点が存在します。空間内の全ての物は、この根源から生成されています。3次元空間を例にとってみると、原点は (0, 0, 0) になり、標準基底(基本ベクトル)は [1,0,0] , [0,1,0] , [0,0,1] となります。(これは、3次元空間だけでなく、2次元空間でも同様です。(0, 0)が原点で、標準基底は [1.0], [0, 1] になります) 。おそらく、標準基底(基本ベクトル)のより一般的な呼び方は、x, y, z軸という名称でしょう。それらのベクトルに関して、加算と内積(スカラー積)を計算することが可能です。これにより、空間内のいかなるベクトルも生成できるのです。

## ベクトルの計算

### 内積(スカラー積)

例えば、「右方向へ (x軸に沿って、最初の基本ベクトルに沿って)」3.14単位だけ行きたいとします。要素をかけ算します。結果は  [1 * 3.14, 0 * 3.14, 0 * 3.14] = [3.14,0,0] となります。同様に「上方向へ (y軸に沿って、二つめの基本ベクトルに沿って)」1.71移動するとします。[0,1,0] * 1.71 = [1 * 1.71,0 * 1.71,0 * 1.71] = [0,1.71,0] と求めることができます。このかけ算は内積(スカラー積)、つまり、方向を一定に保ったままベクトルのスケールを変更しています。(もしスカラー積がマイナス値なら、反転します)。

<script src="/assets/js/vectors.js"></script>
<script src="/assets/js/math_tut/diagrams.js"></script>

<canvas id = "mult" width = "600" height = "250"> </canvas>

<script type="text/javascript">
drawMult();
</script>

openFrameworksでは、* 演算子、または、scale / getScaled で計算できます。

~~~~{.cpp}
ofVec3f v(1,2,3);
return v*3.14; // returns ofVec3f(3.14,6.28,9.42);
return v.getScaled(3.14); // also returns ofVec3f(3.14,6.28,9.42);
v.scale(3.14); // internally scales v to ofVec3f(3.14,6.28,9.42);
//works with vec2f and vec4f as well
ofVec2f v(0,1); return v*2.718; // returns ofVec3f(0,2.718,0);
ofVec4f v(0,1,4,3); return v*2.718; // returns ofVec4f(0,2.718,10.872,8.154);

//note- there is also a * operator which is NOT scalar multiplication-
ofVec3f v1(1,2,3); ofVec3f v2(2,3,4);
return v1*v2; // returns ofVec3f(2,6,12);
// this is component-wise multiplication between two vectors, and is far less common than scalar multiplication
~~~~

[こちら](/ja/documentation/math/ofVec3f/#show_scale)にリファレンスがあります。

### 加算

では、右に3.14移動して、さらに上に1.71動きましょう。ベクトルの単純に足し算することで、ベクトルの加算が可能です。[3.14,0,0] + [0,1.71,0] = [3.14 + 0,0 + 1.71,0 + 0] = [3.14,1.71,0]。これは「要素ごと(component-wise)の加算」と呼ばれます。それぞれのベクトルの要素を単純に足し算します。(例 x + x, y + y, z + z)。これは、1つ目のベクトルの先頭にさらにもう1つのベクトルを追加することで視覚化できます。

<canvas id = "add" width = "600" height = "250">
</canvas>
<script type="text/javascript">
drawAdd();
</script>
<br/>

~~~~{.cpp}
ofVec3f v1(3.14,0,0);
ofVec3f v2(0,1.71,0);
return v1+v2; // returns ofVec3f(3.14,1.71,0);
~~~~

[こちら](/ja/documentation/math/ofVec3f/#show_operator+)にリファレンスがあります。

### 応用

それが何? 役にたつの? では、簡単な例をみてみましょう。空間にaとbという2つの点をつくり、ひとつの点からもう一方の点へと移動しようと思います。ベクトルの加算は、ベクトルの先端にもう一つのベクトルを追加することでした。aからbへの方向を(これをcとしましょう)とaに加算しましょう。すると a + c = b でbを得られます。探していたベクトルは、c = b - a になります。

<canvas id = "diff" width = "600" height = "250">
</canvas>
<script type="text/javascript">
drawDiff();
</script>
<br/>

すばらしい! a地点からb地点への方向がわかりました (c = b - a)。つまり、a点の先端にベクトルcを加算します。するとb点に到達します。もし、ベクトルcに0から1までの範囲でいろいろな数をかけ算すると、aからbへ少しずつ移動することができるようになります。

<canvas id = "aim" width = "600" height = "250">
</canvas>
<script type="text/javascript">
drawAim();
</script>

この新たなベクトル演算をつかって、パーティクルをある地点がら別の地点へとなめらかに移動することができるようになりました。この演算のコンセプトは、3次元空間でも全く同じように使えます。3次元空間で、ある地点から移動する際にも、a + delta * (b - a) の演算を使います。他に何も必要ありません!

## その他の有益な演算

### 長さ / 正規化

ベクトルの長さは、要素の2乗を足しあわせた値の平方根です。え? length(x, y, ...) = sqrt( x * x + y * y + ...) と書いたほうがわかりやすいかもしません。例えば、ベクトル(3, 4)の長さは、 sqrt(3 * 3 + 4 * 4) = sqrt(25) = 5 となります。aからbへ移動するという、このサンプルの目的を忘れないでください。空間上のa点からb点はどのくらい離れているのか、ベクトルc (b - a) の長さからわかるようになりました。この情報は、シミュレーションや多くのグラフィカルな応用に関して、とても重要となります。ベクトルの長さは、しばしば |v| または ||v|| と表記されます。Wikipediaなどで調べると、その意味がわかるでしょう。

正規化は、ベクトルを「単位ベクトル」に変換して、もしくは同じ方向の長さが1の点へのベクトルにして、ベクトルから長さを分離するというコンセプトです。これにより、ベクトルの長さが他の演算から「汚染」されなくなります。例えば、もし最初の例であげた基本ベクトルが正規化されていなかったら、例えば、(1, 0, 0) が (25504.77707, 0, 0) だったら、基本ベクトル * 3.14 = (80085, 0, 0) になってしまいます。これは、直感的ではありません。(ベクトル(3.14, 0, 0)は、実際にx軸上を3.14単位だけ動くと考えるほうが自然です)。v / |v| を計算してみましょう。これは、vの方向の正規化されたベクトルです。

~~~~{.cpp}
ofVec3f v1(3.14,9.11,1.234);
return v1.length(); //returns sqrt(3.14*3.14 + 9.11*9.11 + 1.234*1.234) = 9.71465
v1.normalize(); return v1.length(); // returns 1.
~~~~

### ドット積(点乗積) / 射影 / 反射

ドット積は混乱しがちです。肛門期的な(初歩的な)段階としてのチュートリアルを維持するために、ベクトルaとbのドット積の定義から始めてみましょう。aとbのドット積 [これを dot(a, b) と呼びましょう] は、= |a| * |b| * cos(theta) となります。ここでのthetaは、2つのベクトルの角度をあらわします。先程のセクションで述べたように、|a| と |b| は、ベクトルaとbの長さです。これは、何の役に立つのでしょう? まず始めに、ドット積はいかなる次元(2次元、3次元 .. 10次元?)においても、2つのベクトルの間の角度を、 dot(a, b) = |a| * |b| * cos(theta) という式から得ることができます。theta、つまりベクトル間の角度は、acos(dot(a, b) / |a| * |b|) と等しくなります。(正規化を学んだ動機は、計算を容易にしてくれるからです。もし、aとbが基本ベクトルだったら、これは acos(dot(a, b)) となります)。

もしも、ベクトル間の角度そのものを気にするのではなく、(ベクトルaとbが正規化された際の)cosについて注目すると、dot(a, b) = cos(theta) ととても短かくなります。なぜ、cosの値だけに注目するのでしょう?  cosの値は、thetaが π/2 (90°) 〜 -π/2 (-90°) の範囲の時、正の値になります。ですので、ドット積はベクトルがどれだけ「同じ方向を向いているか」ということを計測することになるのです。もし、閾値 <= dot(a, b) <= 1.0 だったら、それは、複数のベクトルが設定した閾値の範囲でだいたい同じ向きを向いているということになります。もし、dot(a, b)が負の値なら、それらは逆方向を(90°以上の角度)を向いているということになります。もし、きっかり -1 だったら、完全に逆向きになります。具体的な例をあげると、3D描画の際の環境光は、表面を照らすためにドット積を利用します。ドット積の値が、表面の向き(法線)と光線の向きがどのくらい揃っているかと関連しているのです。

<canvas id = "dot" width = "600" height = "250">
</canvas>
<script type="text/javascript">
drawDot();
</script>

ダイアグラムをみるとわかるように、ドット積は一方から他方へのベクトルの射影を計算する際にも使用できます。|b| * dot(a, |b|) だけで求まります。また、ベクトルaからbまでの最小距離を求めることも叶です。ダイアグラムのeの値です。垂直な射影となります。また、ベクトルと他のベクトルが交差する反射を計算することも可能です。d - e ( = 2 * d - a, または、2 * |b| * dot(a, |b|) - a) となります。この数式の美しさは、多次元空間へと抽象化できる点です。もし、平面上のベクトルへの射影を求めたいのであれば、最初の基底へ投射し、2番目の基底へ投射し... と増やしていけます。純粋にドット積だけから全て求まるのです。

openFrameworksでは、ドット積をとても簡単に利用できます。"dot" メソッドを使うだけです。

~~~~{.cpp}
ofVec3f v1(1,2,3);
ofVec3f v2(4,5,6);
return v1.dot(v2); // 1*4 + 2*5 + 3*6 = 32; を返す
~~~~

[こちら](/ja/documentation/math/ofVec3f/#show_dot)にリファレンスがあります。

## 数学的思考のための、ハードコアでナードなやり方

ハードコアにとらえるなら、私たちの「空間」はベクトル空間です。この空間は「ベクトルの加算とスカラー積で閉じている」必要があります。これは、ベクトルの加算とスカラー積の全ての組み合わせは、空間のベクトルであるということを言っています。基本ベクトルはe1, e2, e3.. というように「e」で表記されます。私たちはしばしば正規直交基底(orthonormal)についても議論していることにも注意しましょう。それはe1, e2, e3など全ての基本ベクトルの長さが1であり、それぞれが90°の角度になっていることを意味します。別の例でいうと、ベクトルaとbが直線上に沿っていると仮定すると、ベクトルcは直線へのtanに近似しています。その他にもベクトル空間に関するいくつかの技術的な要件があります。詳しくは [Wikipedia : ベクトル空間](https://ja.wikipedia.org/wiki/%E3%83%99%E3%82%AF%E3%83%88%E3%83%AB%E7%A9%BA%E9%96%93)を参照してください。ドット積は内積とも呼ばれます。長さと内積が定義されていれば「内積空間」を得ることができます。代数幾何学では、内積空間は物体を移動して掛け算することと説明できます dot(a, b) = a(transpose) * b 。ベクトルの長さの2乗は、v(transpose) * v と記述できます。行列による部分空間への投射も似ています。A(transpose) * A * x (Aは平面の基本ベクトルをあらわします) となります。